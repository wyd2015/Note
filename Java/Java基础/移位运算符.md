# Java中的位运算符
## `<<` 左移运算符
在数字没有溢出的情况下，num << n，相当于 $num * 2^n$。  
如果移动的位数超过该类型的最大位数，移进高阶位（第31或63位），该值将变成负数。
### 左移运算规则
1. 按二进制形式把所有的数字向左移动指定位数，高位舍弃，低位补0；
2. 当左操作数是`int`类型，每向左移动1位，从右向左数，它的第31位就要被移出并丢弃；
3. 当左操作数是`long`类型，每向左移动1位，从右向左数，它的第63位就要被移出并丢弃；
4. 当左操作数是`byte`和`short`类型，将自动把这些类型扩大为`int`型再进行运算。
## `>>` 右移运算符
num >> n，相当于$num / 2^n$
### 右移运算规则
1. 按二进制形式把所有的数字向右移动指定位数，低位移出舍弃，高位补符号位（`正数补0，负数补1`）；
2. 当右移的运算数是`byte`和`short`类型，将自动把这些类型扩大为`int`型。
>右移后的值与0x0f进行按位与运算，这样可以舍弃任何的符号位扩展，以便得到的值可以作为定义数组的下标，从而得到对应数组元素代表的十六进制字符。
## `>>>` 无符号右移
忽略符号位，`高位补0`；
## `&` 与
第一个操作数的第n位与第二个操作数的第n位，如果都是1，结果的第n位才为1，否则为0；
## `|` 或
第一个操作数的第n位与第二个操作数的第n位，只要有一个是1，结果的第n位就是1，否则为0；
## `^` 异或
第一个操作数的第n位与第二个操作数的第n，如果两个数不同，结果的第n位才为1，否则为0；
## `~` 非
操作数的第n位为1，结果的第n位就为0，反之结果的第n位为1。

## 原码、补码、反码
### 对于正数（0000 0001）原码
首位表示符号位，反码、补码都是它本身；  
### 对于负数（1000 0001）原码
反码是对`原码`除了符号位之外的所有位做`取反运算`，结果为（1111 1110）；  
补码就是对`反码`做 `+1` 的运算，结果为（1111 1111）。

当涉及到类型强转，如byte强转为int，或在操作时系统检测到byte类型的值最终需要转成int型时，  
位运算就需要`按符号位补位（负数时高位补1，正数时高位补0）`，将8位扩充到32位，再参与运算。