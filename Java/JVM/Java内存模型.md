---
title: 'Java内存模型'
Date: 2019-03-14 01:09:48
categories： Java
tags： Java  JVM
---
主要内容：
- 线程与JVM
- Java内存区域与Java内存模型的区别
- 硬件内存架构与Java内存模型
- Java内存模型与并发特征的保证
# 1. 基本概念
- **程序**：完成某件任务的代码序列（静态）
- **进程**：程序在某些数据上的一次运行（动态）
- **线程**：一个进程可能包含一个或多个线程（是占用资源的独立单位）
# 2. JVM与线程
JVM何时启动？
>当一个类被调用时，会先启动JVM线程，然后再由这个JVM线程负责创建其他的线程（包含main线程）。

那线程在JVM中是如何运行的呢？

这里就需要先明确下Java内存区域的概念了。
# 3. JVM内存区域
首先说明，JVM内存区域并不是从实际物理内存上划分出来的区域，只是一种从逻辑上抽象出来的虚拟区域。

![jvm](img/jvm.png)  

在这种抽象区域里，  
- **方法区**：主要存放`类信息`、`常量`、`static变量`、`JIT` （信息共享）；
- **Java堆区**：主要存放`实例对象`、`GC`  （信息共享）；
- **VM Stack**：Java方法在运行时的内存模型；
![vmStack](img/vmStack.png)
- **Program Counter**：程序计数器，属于线程的私有数据，保存的是线程待执行的下一条指令的地址；
- **Native Method Stack**：本地方法栈，与JVM的native method有关。
# 4. Java内存模型——JMM（规范）
JVM内存区域与JMM并不是同一个概念，
- JMM 是一种规范，一种抽象出来的模型；
- JVM内存区域是根据JMM划分出来的一种虚拟结构。
![JMM](img/JMM.png)
## 4.1 主内存：存放`共享信息`；
## 4.2 工作内存/工作空间：存放`私有信息`
- 基本类型数据：直接分配到工作空间；
- 引用类型变量的地址存放在工作空间，而引用的对象存放在堆中
## 4.3 工作方式：
- 线程修改`私有数据`，直接在工作空间修改；
- 线程修改`共享数据`，有可能引起线程不安全问题，需要先把数据复制到工作空间，在工作空间修改完后，再刷新到内存。
>线程1修改共享数据时，将该数据（x=1）先复制到工作空间中，在线程1的工作空间中将x值加1变成2，
如果此时（线程1还未将x的新值刷新到内存中）线程2恰好来读x的值，那么线程2复制到它的工作空间中的值仍然是1，
此时就出现了线程不安全的问题——脏读。

为了避免出现这种脏读问题，

# 5. 硬件内存架构与Java内存模型
## 5.1 硬件架构
![frame](img/frame.png)
>当一个CPU需要访问主存时，会先读取一部分主存数据存储到CPU缓存，进而在读取CPU缓存到寄存器。
当CPU需要写数据到主存时，同样需要先将寄存器数据flush到CPU缓存，然后再在某些节点将缓存数据flush到主存。
这种硬件架构和运行流程会由于`并发处理不同步`而引起`缓存一致性`问题：

**解决方案：**  
- 总线加锁：粗粒度控制，会降低CPU的吞吐量；
- 缓存一致性协议（MESI）：当CPU在cache memory中操作数据时，如果该数据是共享变量，数据在cache读到寄存器中进行修改，并更新内存数据；此吃会使用`cache line（信号线）`置为无效，其他CPU在使用数据时
