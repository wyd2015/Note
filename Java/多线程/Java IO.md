#  UNIX中的 IO
## 1. IO简介
通常，IO操作包括：对`硬盘`的读写、对`socket`的读写，以及对`外设`的读写。  
一个具体的IO操作过程如下：  
- 查看数据是否准备就绪；
- 进行数据拷贝操作（内核将数据拷贝到用户线程）。  

具体流程如下：
> 当用户线程发起一个IO请求（以读操作为例），内核会去查看要读取的数据是否已经准备就绪。对阻塞IO来说，如果数据没有准备就绪，线程就会一直处于等待状态，直到数据准备就绪；对非阻塞IO来说，如果数据没有准备就绪，就会返回一个标志信息告知用户数据未准备就绪，当数据准备就绪后，内核便将数据拷贝到用户线程，这样才完成一个完整的IO读请求的操作。

阻塞IO和非阻塞IO的区别反映在当用户请求IO操作，如果数据没有准备就绪时，用户线程的处理方式。

## 2. UNIX下的五种I/O模型：  
- 阻塞IO;
- 非阻塞IO；
- IO多路复用(`select`和`poll`)
- 信号驱动IO(`SIGIO`)；
- 异步IO(`Posix.1的aio_系列函数`)

### 2.1 同步I/O vs 异步I/O
同步IO和异步IO，是针对`用户线程和内核的交互`来说的。  

**同步IO**：当用户发出IO请求操作后，如果数据没有准备就绪，需要通过用户线程或内核不断轮询数据是否已就绪，当数据就绪时，再将数据从内核拷贝到用户线程；  
**异步IO**：只有IO请求操作的动作是由用户线程发出的，而IO操作的两个步骤都是由内核自动完成。  

同步IO和异步IO操作的关键区别在于：`数据拷贝阶段是有用户线程完成还是由内核完成`。  
异步IO必须要有操作系统的底层支持！

### 2.2 阻塞I/O vs 非阻塞I/O
#### 2.2.1 阻塞I/O
阻塞I/O下的请求无法立即完成时保持阻塞状态。阻塞IO分为两个阶段：  
- `等待数据就绪`：  
`网络I/O`的情况就是等待远端数据陆续抵达；  
`磁盘I/O`的情况就是等待磁盘数据从磁盘上读取到内核态内存中。
- `数据拷贝`：  
出于系统安全考虑，用户态的程序没有权限直接读取内核态内存。因此，内核负责把内核态内存中的数据拷贝一份到用户态内存中。

#### 2.2.2 非阻塞I/O
非阻塞I/O包括三个阶段：  
- socket设置为`NONBLOCK`(非阻塞)，即是告诉内核，当所请求的I/O操作无法完成时，不要将线程睡眠，而是返回一个错误码（`EWOULDBLOCK`），这样请求就不会阻塞；
- I/O操作函数不断询问数据是否准备完毕，如果没准备好，继续询问，直到数据准备完毕。整个I/O请求的过程中，虽然用户线程每次发起I/O请求后可以立即返回，但为了等到数据准备完，仍需重复发请求进行轮询操作，会消耗大量CPU资源；
- 数据准备完毕，从内核态内存拷贝到用户态内存。

### 2.2.3 IO多路复用（异步阻塞IO）
调用select()/poll()，该方法由一个用户态线程负责轮询多个Channel直到某个阶段1的数据准备就绪，再通知实际的用户线程执行阶段2的数据拷贝。通过一个专职的用户态线程执行非阻塞IO轮询，模拟实现了阶段1的异步化。

### 2.2.4 信号驱动IO(SIGIO)
首先允许socket进行信号驱动IO，并安装一个信号处理函数，线程继续运行不阻塞，当数据准备好，线程会收到一个`SIGIO`信号，可以在信号处理函数中调用IO操作函数处理数据。

### 2.2.5 异步IO
调用`aio_read`函数，告诉内核`描述字`、`缓冲区指针`、`缓冲区大小`、`文件偏移`和`通知方式`，然后立即返回。当内核数据拷贝到缓冲区后，再通知应用程序。因此，异步IO模式下，阶段1和阶段2全部由内核完成，完全不需要用户线程参与。