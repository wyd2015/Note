# Java中的四种IO模型
UNIX下的五种IO模型中，除了`信号驱动IO`外，Java对其余四种IO模型都有所支持。其中，Java最早提供的  
- `BlockingI/O`是阻塞IO；  
- `NIO`为非阻塞IO；  
- 通过NIO实现的`Reactor模式`是I/O复用模型的实现。

## 一、相关概念
### 1. Java IO
**Java IO**是面向`流`的。  
每次从流中读取一个或多个字节，直到读取完所有字节，它们没有被缓存到任何地方。另外，它也不能前后移动流中的数据，如需前后移动，需要先将其缓冲到一个缓冲区中。  

Java IO的各种流都是阻塞的，当某个线程调用read()或write()方法，该线程被阻塞，直到有数据被读取或数据已完全写入。阻塞期间该线程无法处理其他任何事情。

### 2. Java NIO
**Java NIO**是面向`缓冲`的。  
数据会被读取到一个缓冲区，需要时可以在缓冲区中对数据进行前后移动处理。但是在处理缓冲区前需要检查该缓冲区中是否含有需要处理的数据，并需要确保更多数据读入缓冲区时，不会覆盖缓冲区内尚未处理的数据。  

Java NIO为非阻塞模式。读写请求不会阻塞当前线程，在数据可读/写前，当前线程可以做其他事，所以一个单线程可以管理多个输入输出通道。

### 3. 选择器（Selector）
Java NIO的选择器允许一个单独的线程同时监视多个通道（Channel），可以注册多个通道到用一个选择器，然后使用一个单独的线程来“选择”已经就绪的通道。

### 4. 零拷贝
Java NIO中提供的`FileChannel`拥有`transferTo()`和`transferFrom()`两个方法，可直接把FileChannel中的数据拷贝到另外一个Channel，或者直接把另外一个Channel中的数据拷贝到FileChannel。该接口常被用于高效的网络/文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO中提供的方法。