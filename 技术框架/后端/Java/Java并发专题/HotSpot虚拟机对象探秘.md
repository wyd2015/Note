# HotSpot虚拟机对象探秘

## 对象的创建

### Java中创建对象的几种方式：

| 方式                             | --             |
| -------------------------------- | -------------- |
| 使用new关键字                    | 调用构造方法   |
| 使用Class的newInstance()         | 调用构造方法   |
| 使用Constructor类的newInstance() | 调用构造方法   |
| 使用clone()                      | 未调用构造方法 |
| 使用反序列化                     | 未调用构造方法 |

### 对象创建的主要流程

- 虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载操作；
- 类加载通过后，开始分配内存；
  - 若堆中内存规整，使用`指针碰撞`方式；
  - 若堆中内存不规整，使用`空闲列表`方式。
- 并发处理
  - CAS同步；
  - 本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）
- 内存空间初始化；
- 对象设置：元信息、哈希码等；
- 执行init()方法。

#### 为对象分配内存

类加载完成后，会在Java堆中划分一块内存给对象。内存分配根据Java堆是否规整，有两种分配方式：

- **指针碰撞**：如果Java堆规整，即所有用过的内存放一边，而空闲内存在另一边，分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存的工作；
- **空闲列表**：如果Java堆不规整，则需要有虚拟机维护一个列表来记录哪些内存是可用的，这样在分配内存时，可以从该列表中查询到足够大的内存空间分配给对象，并在分配后更新列表记录。

Java堆是否规整是由所采用的垃圾收集器是否带有压缩整理的功能决定的。

#### 处理并发安全问题

由于对象的创建操作在虚拟机中频繁发生，哪怕只是修改一个指针的指向位置的操作，在并发情况下，也是不安全的。可能出现正给对象A分配内存，指针还没来得及修改，对象B又同时使用原来的指针分配内存的情况。解决这种问题又两种方式：

- 对分配内存空间的动作进行同步处理：采用CAS+失败重试来保障更新操作的原子性；
- 把内存分配的动作按线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲。哪个线程需要分配内存，就在那个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁。可通过`-XX:+/-UserTLAB`参数来设定虚拟机是否使用TLAB。

#### 对象的访问定位

Java程序需要通过JVM栈上的引用访问堆中的具体对象，对象的访问方式取决于JVM虚拟机的实现。目前主流的访问方式有两种：**指针**和**句柄**。

##### 指针访问

指向对象，代表一个对象在内存中的地址。

如果使用**直接指针**访问对象，**引用**中存储的直接就是对象地址，那么Java堆对象内部的布局就必须考虑如何防止访问**类型数据**的相关信息。

> 【优势】速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。
>
> HotSpot中采用的就是这种方式。

##### 句柄访问

指向指针的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定的内存地址），再由对象的指针指向对象的真实内存地址。

Java堆中划分出一块内存作为句柄池，引用中存储对象的句柄地址，而句柄中包含了**对象实例数据**与**对象类型数据**各自的具体地址信息。

> 【优势】引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。

