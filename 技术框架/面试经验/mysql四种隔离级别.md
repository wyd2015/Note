# mysql事务

## 一、什么是事务

事务是应用程序中一系列严密的操作，所有操作都必须成功完成，否则所有操作的更改结果都会被撤销。一个事务中的一系列操作要么全部完成，要么全部失败。

事务结束有两种：

- 事务中的所有步骤全部成功执行，事务提交；
- 如果其中一个步骤失败，事务回滚。

## 二、事务的AICD

事务的四个特征：

- 原子性（`Atomicity`）：数据库的逻辑工作单位，事务中包含的操作要么全部成功，要么全部失败；
- 一致性（`Consistency`）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。如果数据库系统运行时发生故障，有些事务尚未完成就被迫中断，并且这些未完成事务对数据库所做的修改有一部分已经写入到数据库中，此时数据库就处于一种不正确的状态（数据不一致）；
- 隔离性（`Isolation`）：一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰；
- 持久性（`Durability`）：一个事务一旦提交，它对数据库中数据的修改是永久性的。

## 三、mysql中锁的种类

mysql中锁的种类很多，常见的有`表锁`和`行锁`，以及新加入的`Metadata Lock`等。

其中，`表锁`是对整张表加锁，虽然可分为读锁和写锁，但毕竟是锁整张表，会导致并发能力下降，一般做`DDL`处理时使用。

`行锁`是锁住某一或多个数据行，这种加锁方式比较复杂，但由于只锁住有限的数据，对其它数据不加限制，并发能力强。mysql一般都是用行级锁来处理并发事务。

以下主要说的也是行级锁。

## 四、4种隔离级别

在数据库操作中，为有效保证并发读取数据的正确性，提出了事务隔离级别。而数据库锁也是为了构建这些隔离级别存在的。

| 隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :------: | :----: | :--------: | :----: |
| 未提交读 |  可能  |    可能    |  可能  |
| 已提交读 | 不可能 |    可能    |  可能  |
| 可重复读 | 不可能 |   不可能   |  可能  |
| 串行化读 | 不可能 |   不可能   | 不可能 |

以下所提及的事务均为不同会话下的事务，不要试图在同一个会话(session)的同一个事务里理解这4种隔离级别的区别。

```sh
MySQL> show create table teacher \G\
Table: class_teacher
Create Table: CREATE TABLE `teacher` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `class_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `t_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_t_id` (`t_id`) #索引
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
1 row in set (0.02 sec)
MySQL> select * from teacher;
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  1 | 初三一班     |          1 |
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

### 1、未提交读 `read uncommited`

会出现`脏读`问题，在这个隔离级别下，所有事务都可以看到其它未提交事务的执行结果。很少用。简单理解就是，事务A在进行select查询后，事务B对其中一条（事务A查询到的其中一条）数据进行修改，但未提交，如果此时事务A再次进行同样的查询，查到的数据是已经修改过的数据，如果此时系统运行异常，事务B进行了回滚操作，则事务A第二次查到的数据就是有问题的数据了。

```sql
--- 设置session的事务隔离级别为：未提交读
SET session transaction isolation level read uncommited;
--- 设置binlog的模式为ROW Level
SET SESSION binlog_format='ROM';
```

| 事务A                               | 事务B                                                  |
| ----------------------------------- | ------------------------------------------------------ |
| start transaction;                  | start transaction;                                     |
| select * from teacher where t_id=2; |                                                        |
|                                     | update teacher set class_name=‘初三三班’ where t_id=2; |
| select * from teacher where t_id=2; |                                                        |
|                                     | commit;                                                |
| select * from teacher where t_id=2; |                                                        |

事务A第一次查询结果为：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

事务A第二次查询结果为：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初三三班     |          2 |
|  4 | 初三三班     |          2 |
+----+--------------+------------+
```

如果事务B正常提交，则事务A第三次查询的结果与第二次结果一致，如果事务B在提交时出现异常导致提交失败，就会对修改操作进行回滚，此时事务A 的第三次查询结果就跟第一次查询的结果一样了。

### 2、已提交读 `read commited`

会出现`不可重复读`的问题。简单理解就是，事务A在进行select查询后，事务B对其中一条（事务A查询到的其中一条）数据进行修改，但未提交，如果此时事务A再次进行同样的查询，则查到的数据与上一次查到的数据一样，并未修改。如果此时事务B进行了提交操作，然后事务A再一次查询，则可以查到修改后的数据。

在`RC`级别，数据的读取时不加锁的，但数据的`写入`、`修改`、`删除`操作是需要加锁的。

```sql
--- 设置session的事务隔离级别为：已提交读
SET session transaction isolation level read commited;
--- 设置binlog的模式为ROW Level
SET SESSION binlog_format='ROM';
```

| 事务A                                                  | 事务B                                                  |
| ------------------------------------------------------ | ------------------------------------------------------ |
| start transaction;                                     | start transaction;                                     |
| update teacher set class_name=‘初三二班’ where t_id=1; | update teacher set class_name=‘初三三班’ where t_id=1; |
| commit;                                                |                                                        |

在`RC`级别下，数据的insert、update、delete操作需要对数据行加锁，为了防止并发过程中出现修改冲突，即如果在此隔离级别下两个事务同时对一行数据进行修改，在事务A未提交（释放锁）之前，事务B一直拿不到锁，会一直处于`wait`状态，直到超时。

这里要注意，`t_id`字段是有索引列，如果是根据没有索引的列（`class_name`）进行修改：

```sql
update teacher set t_id=3 where class_name='初三一班';
```

这种情况下，mysql会对整张表的所有数据行加`行锁`。这是由于class_name不是索引列，mysql在运行过程中并不知道哪些数据行是`class_name=`‘初三一班’的，如果一个条件无法通过索引快速过滤，存储引擎层面会将所有记录加锁后返回，再由msql_server层进行过滤。

不过mysql在实际使用过程中做了一些改进：在Mysql-server过滤条件时，如果发现不满足，会调用`unlock_row`的方法，把不满足条件的记录释放掉锁（`违反了二段锁协议的约束`）。这样做保证了最后只会持有满足条件记录的行上有行锁，但每条记录的加锁操作还是不能省。

这种情况同样适用于`RR`隔离级别。所以对一个数据量很大的表做批量修改时，如果无法使用相同的索引，mysql-server做过滤操作时就会特别慢，可能会出现虽然没有修改某些行的数据，但他们还是被锁住了的现象。

### 3、可重复读 `repeatable read`

MySQL的InnoDB引擎默认的隔离级别，一个事务的多个实例在并发读数据时，会看到同样的数据行。该级别消除了`不可重复读`的问题，但是会存在`幻影读`的问题。

#### 在`RC`隔离级别下

| 事务A                               | 事务B                                                |
| ----------------------------------- | ---------------------------------------------------- |
| start transaction;                  | start transaction;                                   |
| select * from teacher where t_id=2; |                                                      |
|                                     | update teacher set class_name=‘初三三班’ where id=3; |
|                                     | commit;                                              |
| select * from teacher where t_id=2; |                                                      |
| commit;                             |                                                      |

事务A第一次查询得到的结果为：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

事务A第二次查询（事务B提交之后）的结果为：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初三三班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

此时事务A读取到了事务B修改提交后的数据，但正常情况下，事务A在执行自己事务的commit之前，所拿到的数据应该是一样的才对，这里却读取到了事务B提交的修改结果，这种情况就是`不可重复读`。

#### 在`RR`隔离级别下

| 事务A                               | 事务B                                                        | 事务C                                                        |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| start transaction;                  | start transaction;                                           | start transaction;                                           |
| select * from teacher where t_id=2; |                                                              |                                                              |
|                                     | update teacher set class_name=‘初三三班’ where id=3;<br />commit; |                                                              |
|                                     |                                                              | insert into teacher values(null, ‘初三三班’, 1);<br />commit; |
| select * from teacher where t_id=2; |                                                              |                                                              |
| commit;                             |                                                              |                                                              |

事务A第一次的查询结果：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

事务A第二次的查询结果：

```sql
+----+--------------+------------+
| id | class_name   | t_id |
+----+--------------+------------+
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

可以看到，在`RR`级别下，事务A两次读取到的结果是一样的，也即是`可重复读`的，既没有读到事务B的修改结果，也没有读到事务C的新增数据。这一步mysql是如何做到的呢？

#### 不可重复读与幻读的区别

- 不可重复读的重点在`update`和`delete`；
- 幻影读的重点在`insert`。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其他事务在拿不到锁的情况下无法修改这些数据，可实现`可重复读`。但这种方法无法锁住`insert`的数据，所以当事务A先前读取了数据，或修改了全部数据，事务B还是可以`insert`数据并进行提交，这是事务A就会莫名其妙的多了一条之前没有的数据，这就是`幻影读`。幻影读无法通过行锁来避免。

可使用`Serializable`来有效避免幻读、不可重复读、脏读等问题，但会极大降低数据库的并发能力。

不可重复读与幻影读最大的区别：**如何通过锁机制来解决它们产生的问题**。

以上都是使用`悲观锁`的机制来处理问题，但MySQL、Oracle、postgresql等成熟的数据库，处于性能考虑，都是使用了以乐观锁为理论基础的`MVCC(多版本并发控制`来避免这两种问题。

### 4、串行读 `serializable`

每次读都需要获得表级共享锁，读写互斥（相互阻塞）。读时加`共享锁`，写时加`排它锁`，读写互斥，使用悲观锁的理论，实现简单，数据也更加安全，但并发能力差。

如果你的业务并发特别少或压根就没有并发，同时又要求数据及时可靠的话，就可以使用这种隔离级别。

## 五、悲观锁和乐观锁

### 悲观锁

数据对外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度。在整个处理过程中，将数据处于锁定状态，悲观锁的实现往往依靠数据库提供的锁机制，也只有数据库层提供的锁机制能真正保证数据访问的排他性。否则，即使在本系统内实现了加锁机制，也无法保证外部系统不会修改数据。

在悲观锁情况下，为保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务无法修改这些数据，修改删除数据时也要加锁，其他事务无法读取这些数据。

### 乐观锁

悲观锁大多依靠数据库的锁机制实现，以保证操作最大程度的独占性，但代价是数据库性能的巨大开销，对长事务而言更是无法承受。

乐观锁大多是基于`数据版本记录`机制实现的。数据版本是指，在基于数据库表的版本解决方案中，一般通过为数据库表增加一个`version`字段来实现。读取数据时，将次版本号一同读出，之后更新时，在对此版本号加1。此时将提交数据的版本号与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本大于数据库当前版本号，则更新有效，否则就是过期数据。

MVCC的实现没有固定规范，每个数据库都会有不同的实现方式，这里仅讨论InnoDB的MVCC。

