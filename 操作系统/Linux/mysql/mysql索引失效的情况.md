# mysql索引失效的情况

1. 没有查询条件，或使用的查询条件没有索引；

2. 查询条件上没有使用引导列；

3. 查询的数量是总数据的大部分（30%以上）；

4. 索引本身失效；

5. 查询条件在索引列上使用函数计算；

6. 对小表（数据量小的）表进行查询；

7. 提示不使用索引；

8. 统计数据不真实；

9. CBO计算走索引花费过大的情况。其实也包含了上面的情况，这里指的是表占有的block要比索引小；

10. 隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误；

    > 由于表的字段tu_mdn定义为varchar2(20)，但在查询时把该字段作为number类型以where条件传给mysql,这样会导致索引失效：
    > 错误的例子：select * from test where tu_mdn=13333333333; 
    > 正确的例子：select * from test where tu_mdn='13333333333'; 

11. 对索引列进行运算（+，-，\*，/，! 等)）导致索引失效；

12. 使用mysql内部函数导致索引失效，对于这样情况应当创建基于函数的索引。

    >错误的例子：select * from test where round(id)=10; 
    >说明，此时id的索引已经不起作用了 正确的例子：首先建立函数索引， 
    >create index test_id_fbi_idx on test(round(id)); 
    >然后 select * from test where round(id)=10; 这时函数索引起作用了

13. 如果MySQL估计使用索引比全表扫描更慢，则不使用索引；

    >如果列key_part1均匀分布在1到100之间，查询时使用索引就不是很好

    ```
    mysql>select * from table_name where key_part1>1 and key_part<90;
    ```

14. 如果使用MEMORY/HEAP表并且where条件中不使用“=”进行索引列，那么不会用到索引；

    > Heap表只有在“=”的条件下会使用索引，因为用的是哈希索引。

15. 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，涉及的索引都不会被用到；

16. 如果将要使用的索引列不是复合索引列表中的第一部分，则不会使用索引；

17. 如果like是以%开始，可见虽然在name上面建有索引，但是由于where 条件中like的值的“%”在第一位了，那么MySQL也会采用这个索引；

18. 独立的列（对列变量需要计算（聚合运算、类型转换等））；

19. 在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了 索引也不会使用；

20. 在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用；

21. 不要给“性别”增加索引。如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引；

22. 如果对大的文本进行搜索，使用全文索引而不使用like“%...%”；

23. 如果列名是索引，使用column_name is null将使用索引；

24. 不使用`NOT IN`和`<>`操作；

25. 排序的索引问题；

26. 使用短索引；

    > 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

27. 索引不会包含有NULL值的列；

    > 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合\**索引就是无效\**的。所以我们在数据库设计时不要让字段的默认值为NULL。

28. 使用ENUM而不是字符串。

    > ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。



参考资料：[mysql索引之三：索引使用注意规则（索引失效--存在索引但不使用索引）*](https://www.cnblogs.com/duanxz/p/5244703.html)